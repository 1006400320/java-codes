### 内核级线程（KLT）和用户级线程（ULT）
#### 内核级线程（Kemel-Level Threads, KLT 也有叫做内核支持的线程) 
- 线程管理的所有工作（创建和撤销）由操作系统内核完成
- 操作系统内核提供一个应用程序设计接口API，供开发者使用KLT  
##### 纯内核级线程特点：
1. 进程中的一个线程被阻塞，内核能调度同一进程的其他线程（就绪态）占有处理器运行
2. 多处理器环境中，内核能同时调度同一进程的多线程，将这些线程映射到不同的处理器核心上，提高进程的执行效率。
3. 应用程序线程在用户态运行，线程调度和管理在内核实现。线程调度时，控制权从一个线程改变到另一线程，需要模式切换，系统开销较大。

#### 用户级线程（User-Level Threads ULT）
- 用户空间运行线程库，任何应用程序都可以通过使用线程库被设计成多线程程序。线程库是用于用户级线程管理的一个例程包，它提供多线程应用程序的开发和运行支撑环境，包含：用于创建和销毁线程的代码、在线程间传递数据和消息的代码、调度线程执行的代码以及保存和恢复线程上下文的代码。
- 所以线程的创建，消息传递，调度，保存/恢复上下文都有线程库来完成。内核感知不到多线程的存在。内核继续以进程为调度单位，并且给该进程指定一个执行状态（就绪、运行、阻塞等）。

##### 纯用户级线程的特点：
1. 线程切换不需要内核模式，能节省模式切换开销和内核资源。
2. 允许进程按照特定的需要选择不同的调度算法来调度线程。调度算法需要自己实现。
3. 由于其不需要内核进行支持，所以可以跨OS运行。
4. 不能利用多核处理器有点，OS调度进程，每个进程仅有一个ULT能执行
5. 一个ULT阻塞，将导致整个进程的阻塞。


### new Thread的弊端如下：

1. 每次new Thread新建对象性能差。 
2. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 
3. 缺乏更多功能，如定时执行、定期执行、线程中断。

### 线程池的好处在于：

1. 重用存在的线程，减少对象创建、消亡的开销，性能佳。 
2. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 
3. 提供定时执行、定期执行、单线程、并发数控制等功能。



### Java通过Executors提供四种线程池(建议手动创建线程池 ThreadPoolExecutor)

- **newCachedThreadPool** 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。  
- **newFixedThreadPool** 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- **newScheduledThreadPool** 创建一个定长线程池，支持定时及周期性任务执行。
- **newSingleThreadExecutor** 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### ThreadPoolExecutor 创建线程池
ThreadPoolExecutor executorService = new ThreadPoolExecutor(coreSize, poolSize, 0L,
                TimeUnit.MICROSECONDS, new LinkedBlockingQueue<>(200));

#### execute和submit的区别

参考文章： [内核级线程（KLT）和用户级线程（ULT）](https://blog.csdn.net/vinter_he/article/details/79788743)



